/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@curo/calculator/dist/index.es.js":
/*!********************************************************!*\
  !*** ./node_modules/@curo/calculator/dist/index.es.js ***!
  \********************************************************/
/*! exports provided: Calculator, Convention, ActISDA, EU200848EC, EU30360, US30360, SeriesAdvance, SeriesCharge, SeriesPayment, CashFlowBuilder, Frequency, Mode, Profile, CashFlowAdvance, CashFlowCharge, CashFlowPayment, DateUtils, MathUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Calculator\", function() { return Calculator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Convention\", function() { return Convention; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ActISDA\", function() { return ActISDA; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EU200848EC\", function() { return EU200848EC; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EU30360\", function() { return EU30360; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"US30360\", function() { return US30360; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SeriesAdvance\", function() { return SeriesAdvance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SeriesCharge\", function() { return SeriesCharge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SeriesPayment\", function() { return SeriesPayment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CashFlowBuilder\", function() { return CashFlowBuilder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Frequency\", function() { return Frequency; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Mode\", function() { return Mode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Profile\", function() { return Profile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CashFlowAdvance\", function() { return CashFlowAdvance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CashFlowCharge\", function() { return CashFlowCharge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CashFlowPayment\", function() { return CashFlowPayment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DateUtils\", function() { return DateUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MathUtils\", function() { return MathUtils; });\n/**\r\n * Defines the contract for day count convention concrete implementations.\r\n *\r\n * @author Andrew Murphy\r\n */\r\nvar Convention = /** @class */ (function () {\r\n    function Convention() {\r\n    }\r\n    /** Days in a period are counted with reference to the initial draw-down date */\r\n    Convention.DRAWDOWN = \"drawdown\";\r\n    /** Days in a period are counted with reference to a neighbouring cash-flow date */\r\n    Convention.NEIGHBOUR = \"neighbour\";\r\n    return Convention;\r\n}());\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/**\r\n * Math utilities class\r\n */\r\nvar MathUtils = /** @class */ (function () {\r\n    function MathUtils() {\r\n    }\r\n    /**\r\n     * Perform gaussian rounding, also known as “bankers” rounding, convergent rounding, Dutch rounding,\r\n     * or odd–even rounding. This is a method of rounding without statistical bias; regular rounding\r\n     * has a native upwards bias. Gaussian rounding avoids this by rounding to the nearest even\r\n     * number.\r\n     *\r\n     * Source (Tim Down): http://stackoverflow.com/a/3109234\r\n     *\r\n     * @param num to round\r\n     * @param precision (optional) number of decimal places. Default is 0\r\n     */\r\n    MathUtils.gaussRound = function (num, precision) {\r\n        if (precision === void 0) { precision = 0; }\r\n        var d = precision;\r\n        var m = Math.pow(10, d);\r\n        var n = +(d ? num * m : num).toFixed(8);\r\n        var i = Math.floor(n);\r\n        var f = n - i;\r\n        var e = 1e-8;\r\n        var r = f > 0.5 - e && f < 0.5 + e\r\n            ? i % 2 === 0\r\n                ? i\r\n                : i + 1\r\n            : /* istanbul ignore next */ Math.round(n);\r\n        return d ? r / m : r;\r\n    };\r\n    return MathUtils;\r\n}());\n\n/**\r\n * The day count factor applied to the associated cash flow.\r\n *\r\n * @author Andrew Murphy\r\n */\r\nvar DayCountFactor = /** @class */ (function () {\r\n    function DayCountFactor(factor) {\r\n        if (factor === void 0) { factor = 0; }\r\n        this._factor = factor;\r\n        this._operandLog = [];\r\n    }\r\n    Object.defineProperty(DayCountFactor.prototype, \"factor\", {\r\n        get: function () {\r\n            return this._factor;\r\n        },\r\n        set: function (factor) {\r\n            this._factor = factor;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DayCountFactor.prototype, \"operandLog\", {\r\n        get: function () {\r\n            return this._operandLog;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Logs the operands used in deriving the factor. This is useful in constructing\r\n     * calculation proofs, for example to demonstrate how an Annual Percentage\r\n     * Rate (APR) or eXtended Internal Rate of Return (XIRR) was derived.\r\n     *\r\n     * @param numer the numerator defined in days or whole weeks, months or years\r\n     * between two dates\r\n     * @param denom the denominator corresponding to the number of days, weeks or months\r\n     * in a year\r\n     */\r\n    DayCountFactor.prototype.logOperands = function (numer, denom) {\r\n        this._operandLog.push(\"(\" + numer + \"/\" + denom + \")\");\r\n    };\r\n    Object.defineProperty(DayCountFactor.prototype, \"toString\", {\r\n        /**\r\n         * Provides a string representation of the factor equation,\r\n         * with the factor displayed to 8 decimal points\r\n         * e.g. '(31/360) = 0.08611111'\r\n         */\r\n        get: function () {\r\n            var displayText = \"\";\r\n            for (var i = 0; i < this._operandLog.length; i++) {\r\n                displayText = displayText.concat(this._operandLog[i]);\r\n                if (i + 1 !== this._operandLog.length) {\r\n                    displayText = displayText.concat(\" + \");\r\n                }\r\n            }\r\n            displayText = displayText.concat(\" = \");\r\n            displayText = displayText.concat(MathUtils.gaussRound(this.factor, 8).toFixed(8));\r\n            return displayText.toString();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return DayCountFactor;\r\n}());\n\n/**\r\n * The 30/360 (US) day count convention which specifies that the number of days in the\r\n * Calculation Period or Compounding Period in respect of which payment is being made is\r\n * divided by 360, calculated on a formula basis as follows:\r\n *\r\n * > Day Count Fraction = [[360 ∗ (𝑌𝑌2 − 𝑌𝑌1)] + [30 ∗ (𝑀𝑀2 − 𝑀𝑀1)] + (𝐷𝐷2 − 𝐷𝐷1)] / 360\r\n *\r\n * where:\r\n *\r\n * * \"Y1\" is the year, expressed as a number, in which the first day of the Calculation or\r\n * Compounding Period falls;\r\n * * \"Y2\" is the year, expressed as a number, in which the day immediately following the\r\n * last day included in the Calculation Period or Compounding Period falls;\r\n * * \"M1\" is the calendar month, expressed as a number, in which the first day of the Calculation\r\n * Period or Compounding Period falls;\r\n * * \"M2\" is the calendar month, expressed as a number, in which the day immediately following the\r\n * last day included in the Calculation Period or Compounding Period falls;\r\n * * \"D1\" is the first calendar day, expressed as number, of the Calculation Period or Compounding\r\n * Period, unless such number would be 31, in which case D1 will be 30; and\r\n * * \"D2\" is the calendar day, expressed as a number, immediately following the last day included\r\n * in the Calculation Period or Compounding Period, unless such number would be 31 and D1 is\r\n * greater than 29, in which case D2 will be 30.\r\n *\r\n * This convention is also known as \"Bond_Basis_30360\", \"30/360\", \"360/360\" or \"Bond Basis\"\r\n */\r\nvar US30360 = /** @class */ (function (_super) {\r\n    __extends(US30360, _super);\r\n    /**\r\n     * Provides an instance of the 30/360 (US) day count convention object.\r\n     *\r\n     * The default day count instance is suitable for use in all compound interest\r\n     * calculations. With the default setup interest is calculated on the reducing\r\n     * capital balance and is compounded at a frequency typically determined by the\r\n     * time interval between cash flows.\r\n     *\r\n     * For non-compound interest calculations, such as solving for unknowns on the\r\n     * basis of an eXtended Internal Rate of Return (XIRR), set the useXirrMethod\r\n     * constructor parameter to *true*. With this setup the day count is calculated\r\n     * with reference to the first cash flow date in the series, in much the same\r\n     * way as the Microsoft Excel XIRR function does [1].\r\n     *\r\n     * [1] The XIRR function in Excel computes time intervals between the first and\r\n     * subsequent cash flow dates using *actual days*, whereas this implementation\r\n     * offers the flexibility to determine those time intervals on a 30/360 day basis.\r\n     *\r\n     * @param usePostingDates (optional) defines whether the day count between\r\n     * cash flows is computed using cash flow posting dates (true), or alternatively\r\n     * cash flow value dates (false). Default is true.\r\n     * @param inclNonFinFlows (optional) determines whether non-financing cash\r\n     * flows, such as charges or fees within the cash flow profile, are included\r\n     * in the computation of periodic factors. Default is false.\r\n     * @param useXirrMethod (optional) determines whether to use the XIRR method\r\n     * of determining time periods between cash flow dates (true). Default is false.\r\n     */\r\n    function US30360(usePostingDates, inclNonFinFlows, useXirrMethod) {\r\n        if (usePostingDates === void 0) { usePostingDates = true; }\r\n        if (inclNonFinFlows === void 0) { inclNonFinFlows = false; }\r\n        if (useXirrMethod === void 0) { useXirrMethod = false; }\r\n        var _this = _super.call(this) || this;\r\n        _this._usePostingDates = usePostingDates;\r\n        _this._inclNonFinFlows = inclNonFinFlows;\r\n        if (useXirrMethod) {\r\n            _this._dayCountRef = US30360.DRAWDOWN;\r\n        }\r\n        else {\r\n            _this._dayCountRef = US30360.NEIGHBOUR;\r\n        }\r\n        return _this;\r\n    }\r\n    US30360.prototype.dayCountRef = function () {\r\n        return this._dayCountRef;\r\n    };\r\n    US30360.prototype.usePostingDates = function () {\r\n        return this._usePostingDates;\r\n    };\r\n    US30360.prototype.inclNonFinFlows = function () {\r\n        return this._inclNonFinFlows;\r\n    };\r\n    US30360.prototype.computeFactor = function (d1, d2) {\r\n        var dd1 = d1.getDate();\r\n        var mm1 = d1.getMonth();\r\n        var yyyy1 = d1.getFullYear();\r\n        var dd2 = d2.getDate();\r\n        var mm2 = d2.getMonth();\r\n        var yyyy2 = d2.getFullYear();\r\n        var z = 0;\r\n        if (dd1 === 31) {\r\n            z = 30;\r\n        }\r\n        else {\r\n            z = dd1;\r\n        }\r\n        var dt1 = 360 * yyyy1 + 30 * mm1 + z;\r\n        if (dd2 === 31 && (dd1 === 30 || dd1 === 31)) {\r\n            z = 30;\r\n        }\r\n        else if (dd2 === 31 && dd1 < 30) {\r\n            z = dd2;\r\n        }\r\n        else {\r\n            // dd2 < 31\r\n            z = dd2;\r\n        }\r\n        var dt2 = 360 * yyyy2 + 30 * mm2 + z;\r\n        var numerator = Math.abs(dt2 - dt1);\r\n        var factor = numerator / 360;\r\n        var periodFactor = new DayCountFactor(factor);\r\n        periodFactor.logOperands(numerator, 360);\r\n        return periodFactor;\r\n    };\r\n    return US30360;\r\n}(Convention));\n\n/**\r\n * Represents the movement of money, inbound or outbound.\r\n *\r\n * @author Andrew Murphy\r\n */\r\nvar CashFlow = /** @class */ (function () {\r\n    /**\r\n     * Base constructor for derive classes to override.\r\n     *\r\n     * @param postingDate or due date of the cash flow value\r\n     * @param valueDate or settlement date of the cashflow value\r\n     * @param value (optional) the cash flow value if known, alternatively *undefined* if\r\n     * unknown and to be computed\r\n     * @param weighting (optional) the weighting applied to the cash flow relative\r\n     * to other *unknown* cash flow values in the series. Note, the weighting has no effect\r\n     * when applied to known cash flow values. Default value is 1.0\r\n     * @param label free text description of the cash flow e.g. Loan, Payment, Fee, etc.\r\n     */\r\n    function CashFlow(postingDate, valueDate, value, weighting, label) {\r\n        if (label === void 0) { label = \"\"; }\r\n        this._postingDate = new Date(Date.UTC(postingDate.getFullYear(), postingDate.getMonth(), postingDate.getDate()));\r\n        this._valueDate = new Date(Date.UTC(valueDate.getFullYear(), valueDate.getMonth(), valueDate.getDate()));\r\n        if (this._valueDate.getTime() < this._postingDate.getTime()) {\r\n            throw new Error(\"Cash flow value-date cannot predate the posting-date.\");\r\n        }\r\n        if (value === undefined) {\r\n            this._isKnown = false;\r\n            this._value = 0;\r\n        }\r\n        else {\r\n            this._isKnown = true;\r\n            this._value = value;\r\n        }\r\n        if (weighting === undefined) {\r\n            this._weighting = 1.0;\r\n        }\r\n        else {\r\n            this._weighting = Math.abs(weighting);\r\n        }\r\n        this._label = label;\r\n    }\r\n    Object.defineProperty(CashFlow.prototype, \"postingDate\", {\r\n        /**\r\n         * The posting date defines the due date of the cash flow.\r\n         */\r\n        get: function () {\r\n            return this._postingDate;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CashFlow.prototype, \"valueDate\", {\r\n        /**\r\n         * The value date defines the settlement date of the cash flow.\r\n         * It should not predate the posting date.\r\n         */\r\n        get: function () {\r\n            return this._valueDate;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CashFlow.prototype, \"value\", {\r\n        /**\r\n         * The cash flow value which will be positive or negative in\r\n         * accordance with cash flow sign convention.\r\n         */\r\n        get: function () {\r\n            return this._value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Updates the cash flow value, taking into account the weighting factor.\r\n     * @param value to apply to unknown cash flow values\r\n     * @param precision (optional) the number of fractional digits to apply in\r\n     * the rounding of unknown cash flow values. Should only be defined once the\r\n     * unknown value has been solved.\r\n     */\r\n    CashFlow.prototype.updateValue = function (value, precision) {\r\n        if (precision === undefined) {\r\n            // No rounding\r\n            this._value = value * this._weighting;\r\n        }\r\n        else {\r\n            this._value = MathUtils.gaussRound(value * this._weighting, precision);\r\n        }\r\n    };\r\n    Object.defineProperty(CashFlow.prototype, \"isKnown\", {\r\n        /**\r\n         * Flag indicating whether the cash flow value is known, or is to be computed.\r\n         */\r\n        get: function () {\r\n            return this._isKnown;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CashFlow.prototype, \"weighting\", {\r\n        /**\r\n         * The weighting to be applied to the cash flow when the value is unknown.\r\n         * The weighting determines the scale of an unknown cash flow value relative\r\n         * to other unknown cash flows in a cash flow series.\r\n         */\r\n        get: function () {\r\n            return this._weighting;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CashFlow.prototype, \"label\", {\r\n        /**\r\n         * Free text label describing cash flow\r\n         */\r\n        get: function () {\r\n            return this._label;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return CashFlow;\r\n}());\n\n/**\r\n * Represents the movement of money, specifically the cash out flows of a lender,\r\n * for example the amounts advanced under a loan or leasing arrangement.\r\n *\r\n * @author Andrew Murphy\r\n */\r\nvar CashFlowAdvance = /** @class */ (function (_super) {\r\n    __extends(CashFlowAdvance, _super);\r\n    function CashFlowAdvance(postingDate, valueDate, value, weighting, label) {\r\n        return _super.call(this, postingDate, valueDate === undefined ? postingDate : valueDate, value === undefined ? value : -Math.abs(value), weighting, label) || this;\r\n    }\r\n    return CashFlowAdvance;\r\n}(CashFlow));\n\n/**\r\n * Represents the movement of money, specifically interest bearing cash in-flows\r\n * to the lender, for example loan repayments or lease rentals.\r\n *\r\n * @author Andrew Murphy\r\n */\r\nvar CashFlowPayment = /** @class */ (function (_super) {\r\n    __extends(CashFlowPayment, _super);\r\n    function CashFlowPayment(postingDate, value, weighting, isIntCapitalised, label) {\r\n        if (isIntCapitalised === void 0) { isIntCapitalised = true; }\r\n        var _this = _super.call(this, postingDate, postingDate, value === undefined ? value : Math.abs(value), weighting, label) || this;\r\n        _this.interest = 0;\r\n        _this._isIntCapitalized = isIntCapitalised;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Flag indicating whether interest accrued to date is to be capitalised (true)\r\n     * or rolled over (false).\r\n     */\r\n    CashFlowPayment.prototype.isIntCapitalised = function () {\r\n        return this._isIntCapitalized;\r\n    };\r\n    return CashFlowPayment;\r\n}(CashFlow));\n\n/**\r\n * A collection of retrieval and validation utility methods.\r\n */\r\nvar ProfileUtils = /** @class */ (function () {\r\n    function ProfileUtils() {\r\n    }\r\n    /**\r\n     * Retrieve the CashFlowAdvance instance with the earliest posting date,\r\n     * and by extension implicitly confirms the presence of one or more\r\n     * CashFlowAdvance instances within the cash flow series.\r\n     *\r\n     * The posting date of the returned instance serves as the\r\n     * initial drawdown date.\r\n     *\r\n     * @param cashFlows the cash flow series\r\n     * @returns cash outflow instance, or *undefined* to\r\n     * signify a configuration error\r\n     */\r\n    ProfileUtils.firstAdvanceCF = function (cashFlows) {\r\n        return cashFlows\r\n            .filter(function (c) { return c instanceof CashFlowAdvance; })\r\n            .sort(function (c1, c2) {\r\n            if (c1.postingDate < c2.postingDate) {\r\n                return -1;\r\n            }\r\n            else if (c1.postingDate > c2.postingDate) {\r\n                return 1;\r\n            }\r\n            else {\r\n                // Posting dates are equal, sort by value date, earliest first\r\n                if (c1.valueDate < c2.valueDate) {\r\n                    return -1;\r\n                }\r\n                else if (c1.valueDate > c2.valueDate) {\r\n                    return 1;\r\n                }\r\n                return 0;\r\n            }\r\n        })[0];\r\n    };\r\n    /**\r\n     * Check the cash flow series for the presence of one or more CashFlowPayment\r\n     * instances.\r\n     *\r\n     * @param cashFlows the cash flow series\r\n     * @returns true if found, otherwise false to signify an incorrect\r\n     * configuration\r\n     */\r\n    ProfileUtils.hasPaymentCF = function (cashFlows) {\r\n        return cashFlows.filter(function (c) { return c instanceof CashFlowPayment; }).length > 0;\r\n    };\r\n    /**\r\n     * Check for the valid use of the cash flow isKnown property.\r\n     *\r\n     * Solving for unknown values is a mutually exclusive computation\r\n     * performed on either advances, or payments, not on a mix of both.\r\n     * Note it is permissable to have no unknowns, for example when\r\n     * computing implicit interest rates.\r\n     *\r\n     * @param cashFlows the cash flow series\r\n     * @returns\r\n     */\r\n    ProfileUtils.isUnknownsValid = function (cashFlows) {\r\n        var outHas = cashFlows.filter(function (c) { return c instanceof CashFlowAdvance && !c.isKnown; }).length >\r\n            0;\r\n        var inHas = cashFlows.filter(function (c) { return c instanceof CashFlowPayment && !c.isKnown; }).length >\r\n            0;\r\n        if (outHas && inHas) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Check for the valid use of the CashFlowPayment isIntCapitalised\r\n     * property.\r\n     *\r\n     * It is permissable to define a frequency of interest capitalisation\r\n     * that differs from the CashFlowPayment frequency. So to avoid the lost\r\n     * of accrued interest not yet capitalised it is important that the\r\n     * final CashFlowPayment object in the cash flow series always has the\r\n     * isIntCapitalised property set to true.\r\n     *\r\n     * @param cashFlows the cash flow series\r\n     * @returns\r\n     */\r\n    ProfileUtils.isIntCapValid = function (cashFlows) {\r\n        // Extract and sort date descending\r\n        var cfsDesc = cashFlows\r\n            .filter(function (c) { return c instanceof CashFlowPayment; })\r\n            .sort(function (c1, c2) {\r\n            if (c1.postingDate < c2.postingDate) {\r\n                return 1;\r\n            }\r\n            else if (c1.postingDate > c2.postingDate) {\r\n                return -1;\r\n            }\r\n            else {\r\n                return 0;\r\n            }\r\n        });\r\n        // Extract objects sharing the same final posting date and test\r\n        var cfs = cfsDesc.filter(function (c) { return c.postingDate.getTime() === cfsDesc[0].postingDate.getTime(); });\r\n        for (var _i = 0, cfs_1 = cfs; _i < cfs_1.length; _i++) {\r\n            var cf = cfs_1[_i];\r\n            if (cf.isIntCapitalised()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    return ProfileUtils;\r\n}());\n\n/**\r\n * Represents the movement of money, specifically non-interest bearing cash\r\n * in-flows to the lender, for example cash-based charges or fees. The\r\n * value of these cash flows must be specified i.e. they cannot be *undefined*\r\n * or unknown.\r\n *\r\n * The inclusion of charge cash flows in a profile or series has no effect on the\r\n * calculation of unknown interest-bearing cash flow values, they are skipped over.\r\n * However they may optionally be included in the calculation of the implicit interest\r\n * rate in a cash flow series, for example the calculation on an Annual Percentage\r\n * Rate (APR) of charge.\r\n *\r\n * @author Andrew Murphy\r\n */\r\nvar CashFlowCharge = /** @class */ (function (_super) {\r\n    __extends(CashFlowCharge, _super);\r\n    function CashFlowCharge(postingDate, value, label) {\r\n        return _super.call(this, postingDate, postingDate, Math.abs(value), undefined, label) || this;\r\n    }\r\n    return CashFlowCharge;\r\n}(CashFlow));\n\n/**\r\n * A container for a series of cash in-flows and out-flows.\r\n *\r\n * @author Andrew Murphy\r\n */\r\nvar Profile = /** @class */ (function () {\r\n    /**\r\n     * Instantiates a profile instance and performs basic validation.\r\n     *\r\n     * @param cashFlows the collection of advance, payment and charge cash flow objects\r\n     * @param precision (optional) the number of fractional digits to apply in the\r\n     * rounding of cash flow values in the notional currency. Default is 2, with valid\r\n     * options being 0, 2, 3 and 4\r\n     */\r\n    function Profile(cashFlows, precision) {\r\n        if (precision === void 0) { precision = 2; }\r\n        this._cashFlows = cashFlows;\r\n        switch (precision) {\r\n            /* istanbul ignore next */\r\n            case 0:\r\n            case 2:\r\n            case 3:\r\n            case 4:\r\n                this._precision = precision;\r\n                break;\r\n            default:\r\n                throw new Error(\"The precision of \" + precision + \" is unsupported. Valid options are 0, 2, 3 or 4\");\r\n        }\r\n        this._dayCount = new US30360();\r\n        var initialDrawdown = ProfileUtils.firstAdvanceCF(cashFlows);\r\n        if (initialDrawdown !== undefined) {\r\n            this._drawdownPDate = initialDrawdown.postingDate;\r\n            this._drawdownVDate = initialDrawdown.valueDate;\r\n        }\r\n        else {\r\n            /* istanbul ignore next: covered by profile-utils.spec.ts */\r\n            throw new Error(\"The profile must have at least one instance of CashFlowAdvance defined.\");\r\n        }\r\n        if (!ProfileUtils.hasPaymentCF(cashFlows)) {\r\n            /* istanbul ignore next: covered by profile-utils.spec.ts */\r\n            throw new Error(\"The profile must have at least one instance of CashFlowPayment defined.\");\r\n        }\r\n        if (!ProfileUtils.isUnknownsValid(cashFlows)) {\r\n            /* istanbul ignore next: covered by profile-utils.spec.ts */\r\n            throw new Error(\"The profile should not contain a mix of CashFlowAdvance and CashFlowPayment objects with unknown values.\");\r\n        }\r\n        if (!ProfileUtils.isIntCapValid(cashFlows)) {\r\n            /* istanbul ignore next: covered by profile-utils.spec.ts */\r\n            throw new Error(\"The last CashflowPayment object in the profile must have the isIntCapitalised property set to 'true'.\");\r\n        }\r\n    }\r\n    Object.defineProperty(Profile.prototype, \"cashFlows\", {\r\n        /**\r\n         * The cash flow series.\r\n         */\r\n        get: function () {\r\n            return this._cashFlows;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Profile.prototype, \"dayCount\", {\r\n        /**\r\n         * The day count convention applied to cash flows in the series.\r\n         */\r\n        get: function () {\r\n            return this._dayCount;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Profile.prototype, \"drawdownPDate\", {\r\n        /**\r\n         * The posting date of the *first drawdown*. Analogous to a contract date.\r\n         */\r\n        get: function () {\r\n            return this._drawdownPDate;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Profile.prototype, \"drawdownVDate\", {\r\n        /**\r\n         * The value date of the *first drawdown*. This date is ecpected to occur on or\r\n         * after the drawdown posting date and is used specifically in deferred settlement\r\n         * calculations.\r\n         */\r\n        get: function () {\r\n            return this._drawdownVDate;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Profile.prototype, \"precision\", {\r\n        /**\r\n         * The number of fractional digits to apply in the rounding of cash flow values.\r\n         */\r\n        get: function () {\r\n            return this._precision;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Assigns day count factors to each cash flow in the series.\r\n     *\r\n     * @param dayCount day count convention to use in determining time factors\r\n     */\r\n    Profile.prototype.assignFactors = function (dayCount) {\r\n        this._dayCount = dayCount;\r\n        this.sortCashflows();\r\n        this.computeFactors();\r\n    };\r\n    /**\r\n     * Updates the value of cash flows flagged as unknown.\r\n     *\r\n     * @param value the value to assign, which may be negative or positive\r\n     * @param isRounded flag to control rounding of the value prior to update.\r\n     * Rounding should only be undertaken *after* an unknown value has been computed.\r\n     * Default is false, no rounding.\r\n     * @returns value, unmodified or rounded as appropriate\r\n     */\r\n    Profile.prototype.updateValues = function (value, isRounded) {\r\n        if (isRounded === void 0) { isRounded = false; }\r\n        for (var _i = 0, _a = this._cashFlows; _i < _a.length; _i++) {\r\n            var cashFlow = _a[_i];\r\n            if (!cashFlow.isKnown) {\r\n                if (isRounded) {\r\n                    cashFlow.updateValue(value, this._precision);\r\n                }\r\n                else {\r\n                    cashFlow.updateValue(value);\r\n                }\r\n            }\r\n        }\r\n        return value;\r\n    };\r\n    /**\r\n     * Updates the amortised interest value of payment cash flows\r\n     * once the unknown values have been determined.\r\n     *\r\n     * @param intRate annual effective interest rate to use in calculating the\r\n     * interest monetary value\r\n     */\r\n    Profile.prototype.updateAmortInt = function (intRate) {\r\n        var capBal = 0;\r\n        var periodInt;\r\n        var accruedInt = 0;\r\n        for (var _i = 0, _a = this._cashFlows; _i < _a.length; _i++) {\r\n            var cashFlow = _a[_i];\r\n            if (cashFlow instanceof CashFlowCharge) {\r\n                continue;\r\n            }\r\n            periodInt = MathUtils.gaussRound(capBal * intRate * cashFlow.periodFactor.factor, this._precision);\r\n            if (cashFlow instanceof CashFlowPayment) {\r\n                if (cashFlow.isIntCapitalised()) {\r\n                    cashFlow.interest = MathUtils.gaussRound(accruedInt + periodInt, this._precision);\r\n                    capBal += cashFlow.interest + cashFlow.value;\r\n                    accruedInt = 0;\r\n                }\r\n                else {\r\n                    cashFlow.interest = 0;\r\n                    accruedInt += periodInt;\r\n                    capBal += cashFlow.value;\r\n                }\r\n                continue;\r\n            }\r\n            // Cash out flows\r\n            capBal += periodInt + cashFlow.value;\r\n        }\r\n        // Modify interest total in the last cash flow due to account for decrepancies\r\n        // arising from the cumulative effect of rounding differences\r\n        for (var cf = this._cashFlows.length - 1; cf >= 0; cf--) {\r\n            var cashFlow = this._cashFlows[cf];\r\n            if (cashFlow instanceof CashFlowPayment) {\r\n                cashFlow.interest = MathUtils.gaussRound(cashFlow.interest - capBal, this._precision);\r\n                break;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Sort the cash flow series, first in date ascending order, then\r\n     * by instance type CashFlowAdvance first.\r\n     */\r\n    Profile.prototype.sortCashflows = function () {\r\n        var _this = this;\r\n        this._cashFlows.sort(function (cf1, cf2) {\r\n            if (_this.dayCount.usePostingDates()) {\r\n                if (cf1.postingDate < cf2.postingDate) {\r\n                    return -1;\r\n                }\r\n                else if (cf1.postingDate > cf2.postingDate) {\r\n                    return 1;\r\n                }\r\n            }\r\n            else {\r\n                if (cf1.valueDate < cf2.valueDate) {\r\n                    return -1;\r\n                }\r\n                else if (cf1.valueDate > cf2.valueDate) {\r\n                    return 1;\r\n                }\r\n            }\r\n            if (cf1 instanceof CashFlowPayment && cf2 instanceof CashFlowPayment) {\r\n                // Payment objects share the same date, order by\r\n                // isIntCapitalised, false values first\r\n                return (cf1.isIntCapitalised() === cf2.isIntCapitalised()) ? 0 : cf1.isIntCapitalised() ? 1 : -1;\r\n            }\r\n            return cf1 instanceof CashFlowAdvance ? -1 : 1;\r\n        });\r\n    };\r\n    /**\r\n     * Compute the cash flow periodic factors using the day count convention\r\n     * implementation provided.\r\n     */\r\n    Profile.prototype.computeFactors = function () {\r\n        var currDate;\r\n        switch (this._dayCount.dayCountRef()) {\r\n            case Convention.DRAWDOWN:\r\n                for (var _i = 0, _a = this._cashFlows; _i < _a.length; _i++) {\r\n                    var cashFlow = _a[_i];\r\n                    currDate = this.dayCount.usePostingDates()\r\n                        ? cashFlow.postingDate\r\n                        : cashFlow.valueDate;\r\n                    if (cashFlow instanceof CashFlowCharge && !this.dayCount.inclNonFinFlows()) {\r\n                        cashFlow.periodFactor = this.dayCount.computeFactor(currDate, currDate);\r\n                        continue;\r\n                    }\r\n                    cashFlow.periodFactor = this.dayCount.computeFactor(this._drawdownPDate, currDate);\r\n                }\r\n                break;\r\n            case Convention.NEIGHBOUR:\r\n            default:\r\n                var prevDate = void 0;\r\n                for (var _b = 0, _c = this._cashFlows; _b < _c.length; _b++) {\r\n                    var cashFlow = _c[_b];\r\n                    currDate = this.dayCount.usePostingDates()\r\n                        ? cashFlow.postingDate\r\n                        : cashFlow.valueDate;\r\n                    if (cashFlow instanceof CashFlowCharge && !this.dayCount.inclNonFinFlows()) {\r\n                        cashFlow.periodFactor = this.dayCount.computeFactor(currDate, currDate);\r\n                        continue;\r\n                    }\r\n                    if (prevDate === undefined) {\r\n                        // Initialise first cash flow with zero factor\r\n                        cashFlow.periodFactor = this.dayCount.computeFactor(currDate, currDate);\r\n                    }\r\n                    else if (!this.dayCount.usePostingDates() &&\r\n                        currDate <= this._drawdownVDate) {\r\n                        // Factor will be zero for subsequent cash flows when using value dates\r\n                        // *and* where date is earlier or equal to the initial discount date\r\n                        cashFlow.periodFactor = this.dayCount.computeFactor(currDate, currDate);\r\n                    }\r\n                    else {\r\n                        cashFlow.periodFactor = this.dayCount.computeFactor(prevDate, currDate);\r\n                    }\r\n                    prevDate = currDate;\r\n                }\r\n                break;\r\n        }\r\n    };\r\n    return Profile;\r\n}());\n\n/**\r\n * Frequency demarcates the compounding period between two cash flows. Options are:\r\n *\r\n * * Weekly\r\n * * Fortnightly\r\n * * Monthly\r\n * * Quarterly\r\n * * HalfYearly\r\n * * Yearly\r\n */\r\nvar Frequency;\r\n(function (Frequency) {\r\n    Frequency[\"Weekly\"] = \"Weekly\";\r\n    Frequency[\"Fortnightly\"] = \"Fortnightly\";\r\n    Frequency[\"Monthly\"] = \"Monthly\";\r\n    Frequency[\"Quarterly\"] = \"Quarterly\";\r\n    Frequency[\"HalfYearly\"] = \"HalfYearly\";\r\n    Frequency[\"Yearly\"] = \"Yearly\";\r\n})(Frequency || (Frequency = {}));\n\n/**\r\n * Date utilities class\r\n */\r\nvar DateUtils = /** @class */ (function () {\r\n    function DateUtils() {\r\n    }\r\n    /**\r\n     * Compute the actual number of days between two dates.\r\n     */\r\n    DateUtils.actualDays = function (date1, date2) {\r\n        return Math.abs((this.dateToUTC(date1).getTime() - this.dateToUTC(date2).getTime()) /\r\n            this.MS_IN_DAY);\r\n    };\r\n    /**\r\n     * Check if a particular range of years contains a leap-year.\r\n     *\r\n     * @param yearFrom the earlier of two years\r\n     * @param yearTo the later of two years\r\n     * @return true if range includes a leap year, false otherwise\r\n     */\r\n    DateUtils.hasLeapYear = function (yearFrom, yearTo) {\r\n        for (var i = yearFrom; i <= yearTo; i++) {\r\n            if (DateUtils.isLeapYear(i)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Check if a year is a leap year.\r\n     *\r\n     * @param year to check\r\n     * @return true\r\n     */\r\n    DateUtils.isLeapYear = function (year) {\r\n        if (year % 4 === 0) {\r\n            if (year % 100 !== 0) {\r\n                // leap year - divisible by 4 but not 100\r\n                return true;\r\n            }\r\n            else if (year % 400 === 0) {\r\n                // leap year - divisible by 4 and 100 and 400\r\n                return true;\r\n            }\r\n            else {\r\n                // common year - divisible by 4 and 100 but not 400!\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            // common year\r\n            return false;\r\n        }\r\n    };\r\n    /**\r\n     * Transform the given date into an Universal Coordinated Time (UTC) date to\r\n     * remove the side effects of daylight saving within date calculations.\r\n     *\r\n     * @param date to convert\r\n     */\r\n    DateUtils.dateToUTC = function (date) {\r\n        return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));\r\n    };\r\n    /**\r\n     * Roll a date forward by the period implicit in the provided frequency.\r\n     *\r\n     * @param dateToRoll date to roll\r\n     * @param frequency defining the time period to roll forward\r\n     * @param dayPref preferred day of month of returned date\r\n     */\r\n    DateUtils.rollDate = function (dateToRoll, frequency, dayPref) {\r\n        switch (frequency) {\r\n            case Frequency.Weekly:\r\n                return DateUtils.rollDay(dateToRoll, 7);\r\n            case Frequency.Fortnightly:\r\n                return DateUtils.rollDay(dateToRoll, 14);\r\n            case Frequency.Monthly:\r\n                return DateUtils.rollMonth(dateToRoll, 1, dayPref);\r\n            case Frequency.Quarterly:\r\n                return DateUtils.rollMonth(dateToRoll, 3, dayPref);\r\n            case Frequency.HalfYearly:\r\n                return DateUtils.rollMonth(dateToRoll, 6, dayPref);\r\n            case Frequency.Yearly:\r\n                return DateUtils.rollMonth(dateToRoll, 12, dayPref);\r\n            /* istanbul ignore next */\r\n            default:\r\n                return dateToRoll;\r\n        }\r\n    };\r\n    /**\r\n     * Roll a date by the number of days specified.\r\n     *\r\n     * @param dateToRoll date to roll\r\n     * @param numDays days to roll, may be positive (roll forward) or negative (roll backwards)\r\n     */\r\n    DateUtils.rollDay = function (dateToRoll, numDays) {\r\n        dateToRoll = this.dateToUTC(dateToRoll);\r\n        dateToRoll.setUTCDate(dateToRoll.getUTCDate() + numDays);\r\n        return this.dateToUTC(dateToRoll);\r\n    };\r\n    /**\r\n     * Roll a date by the number of months specified.\r\n     *\r\n     * @param dateToRoll date to roll\r\n     * @param numMonths months to roll, may be positive (roll forward) or negative (roll backwards)\r\n     * @param dayPref (optional) preferred day of month of returned date\r\n     */\r\n    DateUtils.rollMonth = function (dateToRoll, numMonths, dayPref) {\r\n        dateToRoll = this.dateToUTC(dateToRoll);\r\n        var currentDay = dateToRoll.getDate();\r\n        var currentMonth = dateToRoll.getMonth();\r\n        var currentYear = dateToRoll.getFullYear();\r\n        // Calculate the new month\r\n        var newMonth = (currentMonth + numMonths) % 12;\r\n        if (newMonth < 0) {\r\n            newMonth += 12;\r\n        }\r\n        // Calculate the new year\r\n        var newYear = currentMonth + numMonths;\r\n        if (newYear < 0) {\r\n            // Roll back\r\n            if (Math.ceil(newYear % 12) !== 0) {\r\n                newYear = Math.ceil(newYear / 12);\r\n                newYear--;\r\n            }\r\n            else {\r\n                newYear = Math.ceil(newYear / 12);\r\n            }\r\n        }\r\n        else {\r\n            // Roll forward\r\n            newYear = Math.floor(newYear / 12);\r\n        }\r\n        newYear = newYear + currentYear;\r\n        // Set the day of month\r\n        if (dayPref === undefined || dayPref <= 0) {\r\n            dayPref = currentDay;\r\n        }\r\n        var newDay;\r\n        if (dayPref > DateUtils.DAYS_IN_MONTH[newMonth]) {\r\n            if (this.isLeapYear(newYear) && newMonth === 1) {\r\n                newDay = 29;\r\n            }\r\n            else {\r\n                newDay = DateUtils.DAYS_IN_MONTH[newMonth];\r\n            }\r\n        }\r\n        else {\r\n            newDay = dayPref;\r\n        }\r\n        return new Date(Date.UTC(newYear, newMonth, newDay));\r\n    };\r\n    /** Milliseconds in a day = (1000 * 60 * 60 * 24) */\r\n    DateUtils.MS_IN_DAY = 86400000;\r\n    /** Number of days in each month starting January (non leap year) */\r\n    DateUtils.DAYS_IN_MONTH = [\r\n        31,\r\n        28,\r\n        31,\r\n        30,\r\n        31,\r\n        30,\r\n        31,\r\n        31,\r\n        30,\r\n        31,\r\n        30,\r\n        31\r\n    ];\r\n    return DateUtils;\r\n}());\n\n/**\r\n * Mode determines whether a cash flow occurs at the start or end of the compounding period\r\n * demarcated by cash flow frequency. The options are:\r\n *\r\n * * Advance - cash flows due at the beginning of a compounding period\r\n * * Arrear - cash flows due at the end of a compounding period\r\n */\r\nvar Mode;\r\n(function (Mode) {\r\n    Mode[\"Advance\"] = \"Advance\";\r\n    Mode[\"Arrear\"] = \"Arrear\";\r\n})(Mode || (Mode = {}));\n\n/**\r\n *\r\n */\r\nvar SeriesType;\r\n(function (SeriesType) {\r\n    SeriesType[\"Advance\"] = \"Advance\";\r\n    SeriesType[\"Payment\"] = \"Payment\";\r\n    SeriesType[\"Charge\"] = \"Charge\";\r\n})(SeriesType || (SeriesType = {}));\n\n/**\r\n * Class for building out a cash flow series into separate cash flow instances of the specific\r\n * type, e.g. advances, payments or charges.\r\n *\r\n * All cash flow instances are dated with reference to the series start date if provided, or\r\n * are computed with reference the current system date when undefined. The interval between cash flows\r\n * is determined by the series frequency, and the series mode determines whether a cash flow value\r\n * occurs at the beginning or end of the period defined by the frequency.\r\n *\r\n * Where the start dates of two or more series of the same type are *defined* it is possible the\r\n * respective cash flow series may overlap. This is intentional to allow for the creation of\r\n * advanced cash flow profiles.\r\n *\r\n * Where the start dates of two or more series of the same type are *undefined*, the start date of\r\n * any subsequent series is determined with reference to the end date of the preceding series. The\r\n * order that each undated series is defined and added to the series array is therefore very\r\n * important as each is processed sequentially.\r\n *\r\n * The mixing of dated and undated series is permissable but discouraged, unless you know what you\r\n * are doing of course. It is recommended you either stick to explicitly defining the start dates of\r\n * *all* cash flow series, or alternativey leave dates undefined and allow the builder to resolve them\r\n * with reference to today's date.\r\n */\r\nvar CashFlowBuilder = /** @class */ (function () {\r\n    function CashFlowBuilder() {\r\n    }\r\n    /**\r\n     * Builds the array of cash flow instances\r\n     *\r\n     * @param series\r\n     * @param today the initial start date to use in the first of an undated cash flow series\r\n     * @return an array of cash flows\r\n     */\r\n    CashFlowBuilder.build = function (series, today) {\r\n        if (series.length < 1) {\r\n            throw new Error(\"The cash flow series is empty. Build aborted.\");\r\n        }\r\n        var cashFlows = [];\r\n        // Keep track of computed dates for undated series\r\n        var nextAdvPeriod = today;\r\n        var nextPmtPeriod = today;\r\n        var nextChgPeriod = today;\r\n        for (var _i = 0, series_1 = series; _i < series_1.length; _i++) {\r\n            var seriesItem = series_1[_i];\r\n            var pDateToUse = void 0;\r\n            var pDateDay = void 0;\r\n            if (seriesItem.postedDate === undefined) {\r\n                // Computed date\r\n                switch (seriesItem.seriesType) {\r\n                    case SeriesType.Advance:\r\n                        pDateToUse = nextAdvPeriod;\r\n                        break;\r\n                    case SeriesType.Payment:\r\n                        pDateToUse = nextPmtPeriod;\r\n                        break;\r\n                    case SeriesType.Charge:\r\n                        pDateToUse = nextChgPeriod;\r\n                        break;\r\n                    /* istanbul ignore next */\r\n                    default:\r\n                        throw new Error(\"SeriesType \" + seriesItem + \" not supported.\");\r\n                }\r\n                pDateDay = today.getDate();\r\n            }\r\n            else {\r\n                // Provided date\r\n                pDateToUse = seriesItem.postedDate;\r\n                pDateDay = pDateToUse.getDate();\r\n            }\r\n            if (seriesItem.mode === Mode.Arrear) {\r\n                pDateToUse = DateUtils.rollDate(pDateToUse, seriesItem.frequency, pDateDay);\r\n            }\r\n            switch (seriesItem.seriesType) {\r\n                case SeriesType.Advance:\r\n                    // Process value dates for advances only\r\n                    var vDateToUse = void 0;\r\n                    var vDateDay = void 0;\r\n                    if (seriesItem.valueDate === undefined) {\r\n                        vDateToUse = pDateToUse;\r\n                        vDateDay = pDateDay;\r\n                    }\r\n                    else {\r\n                        vDateToUse = seriesItem.valueDate;\r\n                        vDateDay = vDateToUse.getDate();\r\n                        if (seriesItem.mode === Mode.Arrear) {\r\n                            vDateToUse = DateUtils.rollDate(vDateToUse, seriesItem.frequency, vDateDay);\r\n                        }\r\n                    }\r\n                    for (var j = 0; j < seriesItem.numberOf; j++) {\r\n                        cashFlows.push(new CashFlowAdvance(pDateToUse, vDateToUse, seriesItem.amount, seriesItem.weighting, seriesItem.label));\r\n                        if (j < seriesItem.numberOf - 1) {\r\n                            pDateToUse = DateUtils.rollDate(pDateToUse, seriesItem.frequency, pDateDay);\r\n                            vDateToUse = DateUtils.rollDate(vDateToUse, seriesItem.frequency, vDateDay);\r\n                        }\r\n                    }\r\n                    if (seriesItem.postedDate === undefined) {\r\n                        if (seriesItem.mode === Mode.Advance) {\r\n                            // Shift current series window end date to the end of the last compounding period\r\n                            nextAdvPeriod = DateUtils.rollDate(pDateToUse, seriesItem.frequency, pDateDay);\r\n                        }\r\n                        else {\r\n                            nextAdvPeriod = pDateToUse;\r\n                        }\r\n                    }\r\n                    break;\r\n                case SeriesType.Payment:\r\n                    for (var j = 0; j < seriesItem.numberOf; j++) {\r\n                        cashFlows.push(new CashFlowPayment(pDateToUse, seriesItem.amount, seriesItem.weighting, seriesItem.isIntCap, seriesItem.label));\r\n                        if (j < seriesItem.numberOf - 1) {\r\n                            pDateToUse = DateUtils.rollDate(pDateToUse, seriesItem.frequency, pDateDay);\r\n                        }\r\n                    }\r\n                    if (seriesItem.postedDate === undefined) {\r\n                        if (seriesItem.mode === Mode.Advance) {\r\n                            // Shift current series window end date to the end of the last compounding period\r\n                            nextPmtPeriod = DateUtils.rollDate(pDateToUse, seriesItem.frequency, pDateDay);\r\n                        }\r\n                        else {\r\n                            nextPmtPeriod = pDateToUse;\r\n                        }\r\n                    }\r\n                    break;\r\n                case SeriesType.Charge:\r\n                    // Charge value must be defined\r\n                    for (var j = 0; j < seriesItem.numberOf; j++) {\r\n                        cashFlows.push(new CashFlowCharge(pDateToUse, (seriesItem.amount === undefined) ? 0.0 : seriesItem.amount, seriesItem.label));\r\n                        if (j < seriesItem.numberOf - 1) {\r\n                            pDateToUse = DateUtils.rollDate(pDateToUse, seriesItem.frequency, pDateDay);\r\n                        }\r\n                    }\r\n                    if (seriesItem.postedDate === undefined) {\r\n                        if (seriesItem.mode === Mode.Advance) {\r\n                            // Shift current series window end date to the end of the last compounding period\r\n                            nextChgPeriod = DateUtils.rollDate(pDateToUse, seriesItem.frequency, pDateDay);\r\n                        }\r\n                        else {\r\n                            nextChgPeriod = pDateToUse;\r\n                        }\r\n                    }\r\n                    break;\r\n                /* istanbul ignore next */\r\n                default:\r\n                    throw new Error(\"SeriesType \" + seriesItem.seriesType + \" not supported\");\r\n            }\r\n        }\r\n        return cashFlows;\r\n    };\r\n    return CashFlowBuilder;\r\n}());\n\n/**\r\n * Implementation of the function for finding the interest rate where the\r\n * net future value (nfv) of cash flows equals zero.\r\n *\r\n * Unlike the similar net present value (npv) calculation solved algebraically\r\n * using regular time periods, this function is designed to find the unknown\r\n * interest rate where time periods may be regular or irregular.\r\n *\r\n * @author Andrew Murphy\r\n */\r\nvar SolveNfv = /** @class */ (function () {\r\n    /**\r\n     * Provides an instance of the SolveNfv object\r\n     *\r\n     * @param profile containing the cash flow series\r\n     * @param dayCount day count convention to use\r\n     */\r\n    function SolveNfv(profile, dayCount) {\r\n        this.profile = profile;\r\n        this.dayCount = dayCount;\r\n        profile.assignFactors(this.dayCount);\r\n    }\r\n    SolveNfv.prototype.label = function () {\r\n        return \"Net Future Value\";\r\n    };\r\n    /**\r\n     * Implementation of the callback function to compute the net future value\r\n     * of the cash flow series using the given interest rate.\r\n     * @param rateGuess interest rate guess, or actual rate if known\r\n     *\r\n     */\r\n    SolveNfv.prototype.compute = function (rateGuess) {\r\n        var capBal = 0;\r\n        switch (this.profile.dayCount.dayCountRef()) {\r\n            case Convention.DRAWDOWN:\r\n                for (var _i = 0, _a = this.profile.cashFlows; _i < _a.length; _i++) {\r\n                    var cashFlow = _a[_i];\r\n                    if (cashFlow instanceof CashFlowCharge && !this.profile.dayCount.inclNonFinFlows()) {\r\n                        continue;\r\n                    }\r\n                    capBal +=\r\n                        cashFlow.value *\r\n                            Math.pow(1 + rateGuess, -cashFlow.periodFactor.factor);\r\n                }\r\n                break;\r\n            case Convention.NEIGHBOUR:\r\n            default:\r\n                var periodInt = void 0;\r\n                var accruedInt = 0;\r\n                for (var _b = 0, _c = this.profile.cashFlows; _b < _c.length; _b++) {\r\n                    var cashFlow = _c[_b];\r\n                    if (cashFlow instanceof CashFlowCharge && !this.profile.dayCount.inclNonFinFlows()) {\r\n                        continue;\r\n                    }\r\n                    periodInt = capBal * rateGuess * cashFlow.periodFactor.factor;\r\n                    if (cashFlow instanceof CashFlowPayment) {\r\n                        if (cashFlow.isIntCapitalised()) {\r\n                            capBal += accruedInt + periodInt + cashFlow.value;\r\n                            accruedInt = 0;\r\n                        }\r\n                        else {\r\n                            accruedInt += periodInt;\r\n                            capBal += cashFlow.value;\r\n                        }\r\n                        continue;\r\n                    }\r\n                    // Cash outflows\r\n                    capBal += periodInt;\r\n                    capBal += cashFlow.value;\r\n                }\r\n                break;\r\n        }\r\n        return capBal;\r\n    };\r\n    return SolveNfv;\r\n}());\n\n/**\r\n * Implementation of the function for finding an unknown cash flow value or values.\r\n *\r\n * @author Andrew Murphy\r\n */\r\nvar SolveCashFlow = /** @class */ (function () {\r\n    /**\r\n     * Provides an instance of the SolveCashFlow object\r\n     *\r\n     * @param profile containing the cash flow series\r\n     * @param dayCount day count convention to use\r\n     * @param effectiveRate interest rate guess\r\n     */\r\n    function SolveCashFlow(profile, dayCount, effectiveRate) {\r\n        this.profile = profile;\r\n        this.dayCount = dayCount;\r\n        this.effectiveRate = effectiveRate;\r\n        this.profile.assignFactors(this.dayCount);\r\n    }\r\n    SolveCashFlow.prototype.label = function () {\r\n        return \"Cash Flow Value\";\r\n    };\r\n    /**\r\n     * Implementation of the callback function to compute the unknown\r\n     * cash flow value/s where the cash flow value guess, compounded at the effective\r\n     * interest rate results in a net future value of zero.\r\n     *\r\n     * @param guess\r\n     */\r\n    SolveCashFlow.prototype.compute = function (guess) {\r\n        this.profile.updateValues(guess);\r\n        var nfv = new SolveNfv(this.profile, this.dayCount);\r\n        return nfv.compute(this.effectiveRate);\r\n    };\r\n    return SolveCashFlow;\r\n}());\n\n/**\r\n * Implementation of the function for finding unknown roots.\r\n *\r\n * This is an enhanced and more efficient implementation of the Newton-Raphson\r\n * method, first outlined by NC Shammas in 'Enhancing Newton's Method'\r\n * (Dr Dobbs Journal, June 2002).\r\n *\r\n * @author Andrew Murphy\r\n * @author Namir Clement Shammas\r\n */\r\nvar SolveRoot = /** @class */ (function () {\r\n    function SolveRoot() {\r\n    }\r\n    /**\r\n     * Solves for the unknown root using the Enhanced Newton-Raphson method.\r\n     *\r\n     * @param cb callback to a root function implementation\r\n     * @param guess initial guess (optional)\r\n     */\r\n    SolveRoot.solve = function (cb, guess) {\r\n        if (guess === void 0) { guess = 0.1; }\r\n        var offset;\r\n        var f0;\r\n        var fp;\r\n        var fm;\r\n        var deriv1;\r\n        var deriv2;\r\n        var g0;\r\n        var g1;\r\n        var g2;\r\n        var countIter = 0;\r\n        do {\r\n            offset = Math.abs(guess) > 1.0 ? 0.01 * guess : 0.01;\r\n            // Compute function values at x, x+offset, and x-offset\r\n            f0 = cb.compute(guess);\r\n            fp = cb.compute(guess + offset);\r\n            fm = cb.compute(guess - offset);\r\n            // Calculate first and second derivatives\r\n            deriv1 = (fp - fm) / (2 * offset);\r\n            deriv2 = (fp - 2 * f0 + fm) / (offset * offset);\r\n            // Calculate 1st guess\r\n            g0 = guess - f0 / deriv1;\r\n            // Calculate refinement of guess\r\n            g1 = guess - f0 / (deriv1 + (deriv2 * (g0 - guess)) / 2);\r\n            // Calculate guess update\r\n            g2 = f0 / (deriv1 + (deriv2 * (g1 - guess)) / 2);\r\n            guess -= g2;\r\n        } while (++countIter < SolveRoot.MAX_ITER &&\r\n            Math.abs(g2) > SolveRoot.TOLERANCE);\r\n        if (countIter >= SolveRoot.MAX_ITER || isNaN(guess)) {\r\n            throw new Error(\"Unable to solve the \" + cb.label() + \" within a maximum \" + SolveRoot.MAX_ITER + \" attempts.\");\r\n        }\r\n        return guess;\r\n    };\r\n    /**  The maximum number of iterations */\r\n    SolveRoot.MAX_ITER = 50;\r\n    /**  The tolerance used to determine convergence */\r\n    SolveRoot.TOLERANCE = 1.0e-7;\r\n    return SolveRoot;\r\n}());\n\n/**\r\n * The calculator class provides the entry point for solving unknown values\r\n * and/or unknown interest rates implicit in a cash flow series.\r\n *\r\n * @author Andrew Murphy\r\n */\r\nvar Calculator = /** @class */ (function () {\r\n    /**\r\n     * Instantiates a calculator instance.\r\n     *\r\n     * @param precision (optional) the number of fractional digits to apply in the\r\n     * rounding of cash flow values in the notional currency. Default is 2, with valid\r\n     * options being 0, 2, 3 and 4\r\n     * @param profile (optional) containing a bespoke collection of cash flows\r\n     * created manually. Use with caution, and only then if the default profile\r\n     * builder doesn't handle a specific use case. Be aware that the precision defined\r\n     * in a bespoke profile takes precedence, hence will override any precision\r\n     * value passed as an argument to this constructor.\r\n     */\r\n    function Calculator(precision, profile) {\r\n        if (precision === void 0) { precision = 2; }\r\n        switch (profile === undefined ? precision : profile.precision) {\r\n            /* istanbul ignore next */\r\n            case 0:\r\n            case 2:\r\n            case 3:\r\n            case 4:\r\n                this._precision = profile === undefined ? precision : profile.precision;\r\n                break;\r\n            default:\r\n                throw new Error(\"The precision of \" + precision + \" is unsupported. Valid options are 0, 2, 3 or 4\");\r\n        }\r\n        if (profile === undefined) {\r\n            this._isBespokeProfile = false;\r\n        }\r\n        else {\r\n            this._isBespokeProfile = true;\r\n            this._profile = profile;\r\n        }\r\n        this._series = [];\r\n    }\r\n    Object.defineProperty(Calculator.prototype, \"precision\", {\r\n        /**\r\n         * Returns the number of fractional digits used in the rounding of\r\n         * cash flow values.\r\n         */\r\n        get: function () {\r\n            return this._precision;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Calculator.prototype, \"profile\", {\r\n        /**\r\n         * Returns a reference to the cash flow profile.\r\n         */\r\n        get: function () {\r\n            if (this._profile === undefined) {\r\n                throw new Error(\"The profile has not been initialised yet.\");\r\n            }\r\n            return this._profile;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Adds a cash flow series item to the series array.\r\n     *\r\n     * Please note the order of addition is important for *undated* series\r\n     * items, as the internal computation of cash flow dates is inferred\r\n     * from the natural order of the series array. Hence a more recent\r\n     * undated series addition is deemed to follow on from another added\r\n     * previously.\r\n     *\r\n     * *Dated* series are unaffected and will use the series start-date provided.\r\n     *\r\n     * @param seriesItem\r\n     */\r\n    Calculator.prototype.add = function (seriesItem) {\r\n        if (this._isBespokeProfile) {\r\n            throw new Error(\"The add(seriesItem) option cannot be used with a user-defined profile.\");\r\n        }\r\n        // Coerce series monetary amount to specified precision\r\n        if (seriesItem.amount !== undefined) {\r\n            seriesItem.amount = MathUtils.gaussRound(seriesItem.amount, this._precision);\r\n        }\r\n        this._series.push(seriesItem);\r\n    };\r\n    /**\r\n     * Solves for an unknown value or values.\r\n     *\r\n     * @param dayCount the convention for determining time intervals\r\n     * between cash flows\r\n     * @param intRate the annual effective interest rate expressed as a decimal\r\n     * e.g. 5.25% is 0.0525 as a decimal\r\n     * @returns the value result, fully weighted\r\n     */\r\n    Calculator.prototype.solveValue = function (dayCount, intRate) {\r\n        if (this._profile === undefined && !this._isBespokeProfile) {\r\n            this.buildProfile();\r\n        }\r\n        var value = SolveRoot.solve(new SolveCashFlow(this.profile, dayCount, intRate));\r\n        value = this.profile.updateValues(value, true);\r\n        this.profile.updateAmortInt(intRate);\r\n        return MathUtils.gaussRound(value, this.precision);\r\n    };\r\n    /**\r\n     * Solves for an unknown interest rate.\r\n     *\r\n     * @param dayCount the convention for determining time intervals\r\n     * between cash flows\r\n     * @returns the interest rate result, expressed as a *decimal*\r\n     */\r\n    Calculator.prototype.solveRate = function (dayCount) {\r\n        if (this._profile === undefined && !this._isBespokeProfile) {\r\n            this.buildProfile();\r\n        }\r\n        return SolveRoot.solve(new SolveNfv(this.profile, dayCount));\r\n    };\r\n    /**\r\n     * Utility method that builds the profile from the cash flow\r\n     * series passed to the add() method.\r\n     *\r\n     */\r\n    Calculator.prototype.buildProfile = function () {\r\n        var today = DateUtils.dateToUTC(new Date());\r\n        var cashFlows = CashFlowBuilder.build(this._series, today);\r\n        this._profile = new Profile(cashFlows, this._precision);\r\n    };\r\n    return Calculator;\r\n}());\n\n/**\r\n * The Actual/ISDA day count convention which follows the ISDA understanding of the\r\n * actual/actual convention included in the 1991 ISDA Definitions.\r\n *\r\n * This convention specifies the actual number of days in the Calculation Period in respect of\r\n * which payment is being made is divided by 365 (or, if any portion of that Calculation Period\r\n * falls in a leap year, the sum of:\r\n * * the actual number of days in that portion of the Calculation Period falling in a leap\r\n * year divided by 366, and;\r\n * * the actual number of days in that portion of the Calculation Period falling in a non-leap\r\n * year divided by 365)\r\n *\r\n * This convention is also known as \"Actual/Actual\", \"Actual/Actual (ISDA)\", \"Act/Act\", or\r\n * \"Act/Act (ISDA)\"\r\n */\r\nvar ActISDA = /** @class */ (function (_super) {\r\n    __extends(ActISDA, _super);\r\n    /**\r\n     * Provides an instance of the Actual/Actual (ISDA) day count convention.\r\n     *\r\n     * The default day count instance is suitable for use in all compound interest\r\n     * calculations. With the default setup interest is calculated on the reducing\r\n     * capital balance and is compounded at a frequency typically determined by the\r\n     * time interval between cash flows.\r\n     *\r\n     * For non-compound interest calculations, such as solving for unknowns on the\r\n     * basis of an eXtended Internal Rate of Return (XIRR), set the useXirrMethod\r\n     * constructor parameter to *true*. With this setup the day count is calculated\r\n     * with reference to the first cash flow date in the series.\r\n     *\r\n     * @param usePostingDates (optional) defines whether the day count between\r\n     * cash flows is computed using cash flow posting dates (true), or alternatively\r\n     * cash flow value dates (false). Default is true.\r\n     * @param inclNonFinFlows (optional) determines whether non-financing cash\r\n     * flows, such as charges or fees within the cash flow profile, are included\r\n     * in the computation of periodic factors. Default is false.\r\n     * @param useXirrMethod (optional) determines whether to use the XIRR method\r\n     * of determining time periods between cash flow dates (true). Default is false.\r\n     */\r\n    function ActISDA(usePostingDates, inclNonFinFlows, useXirrMethod) {\r\n        if (usePostingDates === void 0) { usePostingDates = true; }\r\n        if (inclNonFinFlows === void 0) { inclNonFinFlows = false; }\r\n        if (useXirrMethod === void 0) { useXirrMethod = false; }\r\n        var _this = _super.call(this) || this;\r\n        _this._usePostingDates = usePostingDates;\r\n        _this._inclNonFinFlows = inclNonFinFlows;\r\n        if (useXirrMethod) {\r\n            _this._dayCountRef = ActISDA.DRAWDOWN;\r\n        }\r\n        else {\r\n            _this._dayCountRef = ActISDA.NEIGHBOUR;\r\n        }\r\n        return _this;\r\n    }\r\n    ActISDA.prototype.dayCountRef = function () {\r\n        return this._dayCountRef;\r\n    };\r\n    ActISDA.prototype.usePostingDates = function () {\r\n        return this._usePostingDates;\r\n    };\r\n    ActISDA.prototype.inclNonFinFlows = function () {\r\n        return this._inclNonFinFlows;\r\n    };\r\n    ActISDA.prototype.computeFactor = function (d1, d2) {\r\n        var startDateYear = d1.getFullYear();\r\n        var endDateYear = d2.getFullYear();\r\n        var periodFactor;\r\n        var numerator;\r\n        var denominator;\r\n        var factor = 0;\r\n        if (startDateYear === endDateYear) {\r\n            /*\r\n             * Common case - both dates fall within the same leap-year or non leap-year,\r\n             * so no need to split factor calculation\r\n             */\r\n            numerator = DateUtils.actualDays(d1, d2);\r\n            denominator = DateUtils.isLeapYear(startDateYear) ? 366 : 365;\r\n            factor = numerator / denominator;\r\n            periodFactor = new DayCountFactor(factor);\r\n            periodFactor.logOperands(numerator, denominator);\r\n        }\r\n        else if (!DateUtils.hasLeapYear(startDateYear, endDateYear)) {\r\n            /*\r\n             * Dates do not span or fall within a leap year\r\n             */\r\n            numerator = DateUtils.actualDays(d1, d2);\r\n            factor = numerator / 365;\r\n            periodFactor = new DayCountFactor(factor);\r\n            periodFactor.logOperands(numerator, 365.0);\r\n        }\r\n        else {\r\n            /*\r\n             * There is a leap year in the date range so split factor calculation.\r\n             * Handle partial period in year 1, and whole years thereafter (if necessary)\r\n             */\r\n            periodFactor = new DayCountFactor();\r\n            var yearEnd = void 0;\r\n            while (startDateYear !== endDateYear) {\r\n                yearEnd = new Date(startDateYear, 11, 31);\r\n                numerator = DateUtils.actualDays(d1, yearEnd);\r\n                denominator = DateUtils.isLeapYear(startDateYear) ? 366.0 : 365.0;\r\n                factor += numerator / denominator;\r\n                if (numerator > 0) {\r\n                    // Do not log when numerator 0 (it will be when start date is last day of year)\r\n                    periodFactor.logOperands(numerator, denominator);\r\n                }\r\n                d1 = yearEnd;\r\n                startDateYear++;\r\n            }\r\n            // Process partial final year period\r\n            numerator = DateUtils.actualDays(d1, d2);\r\n            denominator = DateUtils.isLeapYear(endDateYear) ? 366.0 : 365.0;\r\n            factor += numerator / denominator;\r\n            periodFactor.factor = factor;\r\n            periodFactor.logOperands(numerator, denominator);\r\n        }\r\n        return periodFactor;\r\n    };\r\n    return ActISDA;\r\n}(Convention));\n\n/**\r\n * The European Union Directive 2008/48/EC (Consumer Credit Directive) day count\r\n * convention, used exclusively within EU member states in the computation of the\r\n * Annual Percentage Rate of Charge (APRC) for consumer credit agreements.\r\n *\r\n * An APRC is used as a measure of the total cost of the credit to the consumer,\r\n * expressed as an annual percentage of the total amount of credit.\r\n *\r\n * The document containing the rules for determining time intervals can be found at\r\n * https://ec.europa.eu/info/sites/info/files/guidelines_final.pdf (see ANNEX 1,\r\n * section 4.1.1)\r\n *\r\n * @author Andrew Murphy\r\n */\r\nvar EU200848EC = /** @class */ (function (_super) {\r\n    __extends(EU200848EC, _super);\r\n    /**\r\n     * Provides an instance of the 2008/48/EC day count convention object\r\n     * for solving the Annual Percentage Rate (APR) of charge for consumer\r\n     * credit transactions throughout the European Union.\r\n     *\r\n     * @param frequency the interval between dates used in the calculation.\r\n     * Options are 'year', 'month' or 'week'. For the choice among years,\r\n     * months or weeks, consideration should be given to the frequency of\r\n     * drawdowns and payments within the cash flow series. Refer to the\r\n     * directive for further guidance. Default is 'month' if undefined.\r\n     */\r\n    function EU200848EC(frequency) {\r\n        if (frequency === void 0) { frequency = EU200848EC.MONTH; }\r\n        var _this = _super.call(this) || this;\r\n        switch (frequency) {\r\n            case EU200848EC.YEAR:\r\n                _this._frequency = EU200848EC.YEAR;\r\n                _this._periodsInYr = 1;\r\n                break;\r\n            case EU200848EC.WEEK:\r\n                _this._frequency = EU200848EC.WEEK;\r\n                _this._periodsInYr = 52;\r\n                break;\r\n            case EU200848EC.MONTH:\r\n            default:\r\n                _this._frequency = EU200848EC.MONTH;\r\n                _this._periodsInYr = 12;\r\n                break;\r\n        }\r\n        return _this;\r\n    }\r\n    EU200848EC.prototype.frequency = function () {\r\n        return this._frequency;\r\n    };\r\n    EU200848EC.prototype.dayCountRef = function () {\r\n        return EU200848EC.DRAWDOWN;\r\n    };\r\n    EU200848EC.prototype.usePostingDates = function () {\r\n        return true;\r\n    };\r\n    EU200848EC.prototype.inclNonFinFlows = function () {\r\n        return true;\r\n    };\r\n    /**\r\n     * Computes the time interval between dates, expressed in periods defined by the cash flow\r\n     * series frequency. Where the interval between dates used in the calculation cannot be\r\n     * expressed in whole periods, the interval is expressed in whole periods and remaining\r\n     * number of days divided by 365 (or 366 in a leap-year), calculated *backwards* from the\r\n     * cash flow date to the initial drawdown date.\r\n     *\r\n     * @param d1 the initial drawdown date\r\n     * @param d2 posting date of the cash flow\r\n     */\r\n    EU200848EC.prototype.computeFactor = function (d1, d2) {\r\n        // Compute whole periods\r\n        var wholePeriods = 0;\r\n        var startWholePeriod = d2;\r\n        while (true) {\r\n            var tempDate = void 0;\r\n            switch (this._frequency) {\r\n                case EU200848EC.YEAR:\r\n                    tempDate = DateUtils.rollMonth(startWholePeriod, -12);\r\n                    break;\r\n                case EU200848EC.WEEK:\r\n                    tempDate = DateUtils.rollDay(startWholePeriod, -7);\r\n                    break;\r\n                case EU200848EC.MONTH:\r\n                default:\r\n                    tempDate = DateUtils.rollMonth(startWholePeriod, -1);\r\n                    break;\r\n            }\r\n            if (tempDate >= d1) {\r\n                startWholePeriod = tempDate;\r\n                wholePeriods++;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        var periodFactor = new DayCountFactor(0);\r\n        var factor = 0;\r\n        if (wholePeriods > 0) {\r\n            factor = wholePeriods / this._periodsInYr;\r\n            periodFactor.factor = factor;\r\n            periodFactor.logOperands(wholePeriods, this._periodsInYr);\r\n        }\r\n        // Compute days remaining if necessary\r\n        if (startWholePeriod >= d1) {\r\n            var numerator = DateUtils.actualDays(d1, startWholePeriod);\r\n            var startDenPeriod = DateUtils.rollMonth(startWholePeriod, -12);\r\n            var denominator = DateUtils.actualDays(startDenPeriod, startWholePeriod);\r\n            periodFactor.factor = factor + numerator / denominator;\r\n            if (numerator > 0 || periodFactor.operandLog.length === 0) {\r\n                periodFactor.logOperands(numerator, denominator);\r\n            }\r\n        }\r\n        return periodFactor;\r\n    };\r\n    EU200848EC.YEAR = \"year\";\r\n    EU200848EC.MONTH = \"month\";\r\n    EU200848EC.WEEK = \"week\";\r\n    return EU200848EC;\r\n}(Convention));\n\n/**\r\n * The 30/360 (EU) day count convention which specifies that the number of days in the\r\n * Calculation or Compounding Period in respect of which payment is being made is\r\n * divided by 360, calculated on a formula basis as follows:\r\n *\r\n * > Day Count Fraction = [[360 ∗ (𝑌𝑌2 − 𝑌𝑌1)] + [30 ∗ (𝑀𝑀2 − 𝑀𝑀1)] + (𝐷𝐷2 − 𝐷𝐷1)] / 360\r\n *\r\n * where:\r\n *\r\n * * \"Y1\" is the year, expressed as a number, in which the first day of the Calculation or\r\n * Compounding Period falls;\r\n * * \"Y2\" is the year, expressed as a number, in which the day immediately following the\r\n * last day included in the Calculation Period or Compounding Period falls;\r\n * * \"M1\" is the calendar month, expressed as a number, in which the first day of the Calculation\r\n * Period or Compounding Period falls;\r\n * * \"M2\" is the calendar month, expressed as a number, in which the day immediately following the\r\n * last day included in the Calculation Period or Compounding Period falls;\r\n * * \"D1\" is the first calendar day, expressed as number, of the Calculation Period or Compounding\r\n * Period, unless such number would be 31, in which case D1 will be 30; and\r\n * * \"D2\" is the calendar day, expressed as a number, immediately following the last day included\r\n * in the Calculation Period or Compounding Period, unless such number would be 31,\r\n * in which case D2 will be 30.\r\n *\r\n * This convention is also known as \"30E/360\" or \"Eurobond basis\".\r\n */\r\nvar EU30360 = /** @class */ (function (_super) {\r\n    __extends(EU30360, _super);\r\n    /**\r\n     * Provides an instance of the 30/360 (EU) day count convention object.\r\n     *\r\n     * The default day count instance is suitable for use in all compound interest\r\n     * calculations. With the default setup interest is calculated on the reducing\r\n     * capital balance and is compounded at a frequency typically determined by the\r\n     * time interval between cash flows.\r\n     *\r\n     * For non-compound interest calculations, such as solving for unknowns on the\r\n     * basis of an eXtended Internal Rate of Return (XIRR), set the useXirrMethod\r\n     * constructor parameter to *true*. With this setup the day count is calculated\r\n     * with reference to the first cash flow date in the series, in much the same\r\n     * way as the Microsoft Excel XIRR function does [1].\r\n     *\r\n     * [1] The XIRR function in Excel computes time intervals between the first and\r\n     * subsequent cash flow dates using *actual days*, whereas this implementation\r\n     * offers the flexibility to determine those time intervals on a 30/360 day basis.\r\n     *\r\n     * @param usePostingDates (optional) defines whether the day count between\r\n     * cash flows is computed using cash flow posting dates (true), or alternatively\r\n     * cash flow value dates (false). Default is true.\r\n     * @param inclNonFinFlows (optional) determines whether non-financing cash\r\n     * flows, such as charges or fees within the cash flow profile, are included\r\n     * in the computation of periodic factors. Default is false.\r\n     * @param useXirrMethod (optional) determines whether to use the XIRR method\r\n     * of determining time periods between cash flow dates (true). Default is false.\r\n     */\r\n    function EU30360(usePostingDates, inclNonFinFlows, useXirrMethod) {\r\n        if (usePostingDates === void 0) { usePostingDates = true; }\r\n        if (inclNonFinFlows === void 0) { inclNonFinFlows = false; }\r\n        if (useXirrMethod === void 0) { useXirrMethod = false; }\r\n        var _this = _super.call(this) || this;\r\n        _this._usePostingDates = usePostingDates;\r\n        _this._inclNonFinFlows = inclNonFinFlows;\r\n        if (useXirrMethod) {\r\n            _this._dayCountRef = EU30360.DRAWDOWN;\r\n        }\r\n        else {\r\n            _this._dayCountRef = EU30360.NEIGHBOUR;\r\n        }\r\n        return _this;\r\n    }\r\n    EU30360.prototype.dayCountRef = function () {\r\n        return this._dayCountRef;\r\n    };\r\n    EU30360.prototype.usePostingDates = function () {\r\n        return this._usePostingDates;\r\n    };\r\n    EU30360.prototype.inclNonFinFlows = function () {\r\n        return this._inclNonFinFlows;\r\n    };\r\n    EU30360.prototype.computeFactor = function (d1, d2) {\r\n        var dd1 = d1.getDate();\r\n        var mm1 = d1.getMonth();\r\n        var yyyy1 = d1.getFullYear();\r\n        var dd2 = d2.getDate();\r\n        var mm2 = d2.getMonth();\r\n        var yyyy2 = d2.getFullYear();\r\n        var z = 0;\r\n        if (dd1 === 31) {\r\n            z = 30;\r\n        }\r\n        else {\r\n            z = dd1;\r\n        }\r\n        var dt1 = 360 * yyyy1 + 30 * mm1 + z;\r\n        if (dd2 === 31) {\r\n            z = 30;\r\n        }\r\n        else {\r\n            // dd2 < 31\r\n            z = dd2;\r\n        }\r\n        var dt2 = 360 * yyyy2 + 30 * mm2 + z;\r\n        var numerator = Math.abs(dt2 - dt1);\r\n        var factor = numerator / 360;\r\n        var periodFactor = new DayCountFactor(factor);\r\n        periodFactor.logOperands(numerator, 360);\r\n        return periodFactor;\r\n    };\r\n    return EU30360;\r\n}(Convention));\n\n/**\r\n * A generic class containing a superset of cash flow series properties.\r\n *\r\n * This class should not be instantiated directly. Use the SeriesAdvance, SeriesCharge\r\n * and SeriesPayment classes to build the respective series.\r\n */\r\nvar Series = /** @class */ (function () {\r\n    function Series(seriesType) {\r\n        this._seriesType = seriesType;\r\n        this.numberOf = 1.0;\r\n        this.frequency = Frequency.Monthly;\r\n        this.mode = Mode.Advance;\r\n        this.weighting = 1.0;\r\n        this.isIntCap = true;\r\n    }\r\n    Object.defineProperty(Series.prototype, \"seriesType\", {\r\n        get: function () {\r\n            return this._seriesType;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return Series;\r\n}());\n\n/**\r\n * A series of one or more advances paid out by a lender. This could comprise a series of\r\n * amounts loaned to a borrower, a lessor's net investment in a lease agreement, etc.\r\n *\r\n * This class implements the builder pattern to provide a fluent-type API.\r\n */\r\nvar SeriesAdvance = /** @class */ (function () {\r\n    function SeriesAdvance() {\r\n        this._seriesAdvance = new Series(SeriesType.Advance);\r\n    }\r\n    /**\r\n     * Instantiates a default instance of this class to capture user-defined input\r\n     */\r\n    SeriesAdvance.builder = function () {\r\n        return new SeriesAdvance();\r\n    };\r\n    /**\r\n     * The label assigned to each cash flow in the series. Used to annotate\r\n     * each cash flow in an amortisation schedule or calculation proof.\r\n     *\r\n     * @param label containing localised text in singular form e.g. 'Loan advance'\r\n     */\r\n    SeriesAdvance.prototype.setLabel = function (label) {\r\n        this._seriesAdvance.label = label;\r\n        return this;\r\n    };\r\n    /**\r\n     * The total number of advances in the series. Default is 1.\r\n     *\r\n     * @param numberOf determining total number of cash flows in series\r\n     * @throws error when numberOf argument is less than 1\r\n     */\r\n    SeriesAdvance.prototype.setNumberOf = function (numberOf) {\r\n        if (numberOf < 1) {\r\n            throw new Error(\"The numberOf value must be 1 or greater\");\r\n        }\r\n        this._seriesAdvance.numberOf = Math.floor(numberOf);\r\n        return this;\r\n    };\r\n    /**\r\n     * The value of the one or more advances in the series. Leave the amount\r\n     * undefined if it is to be solved.\r\n     *\r\n     * @param amount to assign to each cash flow object created.\r\n     */\r\n    SeriesAdvance.prototype.setAmount = function (amount) {\r\n        this._seriesAdvance.amount = amount;\r\n        return this;\r\n    };\r\n    /**\r\n     * The posted or drawdown date of the first advance in the series. Subsequent advance\r\n     * drawdown dates are determined with reference to this date *and* are offset\r\n     * by the interval defined by the series frequency.\r\n     *\r\n     * If the date is not defined it will be computed with reference to the current\r\n     * system date or the end date of a preceding advance series.\r\n     *\r\n     * @param creditedFrom posted date of the first cash flow in the series\r\n     */\r\n    SeriesAdvance.prototype.setDrawdownFrom = function (creditedFrom) {\r\n        this._seriesAdvance.postedDate = creditedFrom;\r\n        return this;\r\n    };\r\n    /**\r\n     * The value or settlement date of the first advance in the series. This date is expected\r\n     * to fall on or after the setDrawdownFrom date. Subsequent advance settlement dates\r\n     * are determined with reference to this date *and* are offset by the interval\r\n     * defined by the series frequency.\r\n     *\r\n     * The series value date will usually differ from the posted date only when the\r\n     * advance series models a deferred settlement scheme.\r\n     *\r\n     * If the date is not defined it will share the same setDrawdownFrom date.\r\n     *\r\n     * @param settlement value date of the first cash flow in the series\r\n     */\r\n    SeriesAdvance.prototype.setSettlementOn = function (settlement) {\r\n        this._seriesAdvance.valueDate = settlement;\r\n        return this;\r\n    };\r\n    /**\r\n     * The compounding frequency of recurring advances in the series.\r\n     *\r\n     * @param frequency of the one or more advance cash flows in the series.\r\n     */\r\n    SeriesAdvance.prototype.setFrequency = function (frequency) {\r\n        this._seriesAdvance.frequency = frequency;\r\n        return this;\r\n    };\r\n    /**\r\n     * The mode of recurring advances in the series.\r\n     *\r\n     * @param mode of the one or more advance cash flows in the series\r\n     */\r\n    SeriesAdvance.prototype.setMode = function (mode) {\r\n        this._seriesAdvance.mode = mode;\r\n        return this;\r\n    };\r\n    /**\r\n     * The weighting of unknown advance series values relative to other unknown advance\r\n     * series values.\r\n     *\r\n     * @param weighting to apply to the advance cash flows in the series\r\n     * @throws error when weighting value is zero or negative\r\n     */\r\n    SeriesAdvance.prototype.setWeighting = function (weighting) {\r\n        if (!(weighting > 0)) {\r\n            throw new Error(\"The AdvanceSeries weighting value must be greater than 0\");\r\n        }\r\n        this._seriesAdvance.weighting = weighting;\r\n        return this;\r\n    };\r\n    /**\r\n     * Method provides a reference to the populated instance once input has been validated.\r\n     *\r\n     */\r\n    SeriesAdvance.prototype.build = function () {\r\n        if (this._seriesAdvance.valueDate !== undefined &&\r\n            this._seriesAdvance.postedDate === undefined) {\r\n            throw new Error(\"The Advance drawdown date must be entered when a settlement date is defined.\");\r\n        }\r\n        else if (this._seriesAdvance.postedDate !== undefined &&\r\n            this._seriesAdvance.valueDate !== undefined &&\r\n            this._seriesAdvance.valueDate.getTime() < this._seriesAdvance.postedDate.getTime()) {\r\n            throw new Error(\"The Advance settlement date must fall on or after the drawdown date.\");\r\n        }\r\n        return this._seriesAdvance;\r\n    };\r\n    return SeriesAdvance;\r\n}());\n\n/**\r\n * A series of one or more charges or fees received by a lender. These are non-finance cash flows\r\n * that do not affect the computation of unknown advance or payment cash flow values, but may affect\r\n * the computation of implicit interest rates such as Annual Percantage Rates (APRs), as documented\r\n * elsewhere.\r\n *\r\n * This class implements the builder pattern to provide a fluent-type API.\r\n */\r\nvar SeriesCharge = /** @class */ (function () {\r\n    function SeriesCharge() {\r\n        this._seriesCharge = new Series(SeriesType.Charge);\r\n    }\r\n    /**\r\n     * Instantiates a default instance of this class to capture user-defined input\r\n     */\r\n    SeriesCharge.builder = function () {\r\n        return new SeriesCharge();\r\n    };\r\n    /**\r\n     * The label assigned to each cash flow in the series. Used to annotate\r\n     * each cash flow in an amortisation schedule or calculation proof.\r\n     *\r\n     * @param label containing localised  text in singular form e.g. 'Arrangement\r\n     * fee' (not 'Arrangement fees')\r\n     */\r\n    SeriesCharge.prototype.setLabel = function (label) {\r\n        this._seriesCharge.label = label;\r\n        return this;\r\n    };\r\n    /**\r\n     * The total number of charges in the series. Default is 1.\r\n     *\r\n     * @param numberOf determining total number of cash flows in series\r\n     * @throws error when numberOf argument is less than 1\r\n     */\r\n    SeriesCharge.prototype.setNumberOf = function (numberOf) {\r\n        if (numberOf < 1) {\r\n            throw new Error(\"The numberOf value must be 1 or greater\");\r\n        }\r\n        this._seriesCharge.numberOf = numberOf;\r\n        return this;\r\n    };\r\n    /**\r\n     * The value of the one or more charges in the series.\r\n     *\r\n     * @param amount to assign to each cash flow object created.\r\n     */\r\n    SeriesCharge.prototype.setAmount = function (amount) {\r\n        this._seriesCharge.amount = amount;\r\n        return this;\r\n    };\r\n    /**\r\n     * The due date of the first charge in the series. Subsequent charge\r\n     * cash flow dates are determined with reference to this date *and* are offset\r\n     * by the interval defined by the series frequency.\r\n     *\r\n     * If the date is not defined it will be computed with reference to the current\r\n     * system date or the end date of a preceding charge series.\r\n     *\r\n     * @param payableFrom posted date of the first cash flow in the series\r\n     */\r\n    SeriesCharge.prototype.setDueOnOrFrom = function (payableFrom) {\r\n        this._seriesCharge.postedDate = payableFrom;\r\n        return this;\r\n    };\r\n    /**\r\n     * The frequency of recurring charges in the series.\r\n     *\r\n     * @param frequency of the one or more charge cash flows in the series.\r\n     */\r\n    SeriesCharge.prototype.setFrequency = function (frequency) {\r\n        this._seriesCharge.frequency = frequency;\r\n        return this;\r\n    };\r\n    /**\r\n     * The mode of recurring charges in the series.\r\n     *\r\n     * @param mode of the one or more charge cash flows in the series\r\n     */\r\n    SeriesCharge.prototype.setMode = function (mode) {\r\n        this._seriesCharge.mode = mode;\r\n        return this;\r\n    };\r\n    /**\r\n     * Method provides a reference to the populated instance after all user\r\n     * input has been captured.\r\n     */\r\n    SeriesCharge.prototype.build = function () {\r\n        return this._seriesCharge;\r\n    };\r\n    return SeriesCharge;\r\n}());\n\n/**\r\n * A series of one or more loan payments, lease rentals, etc., received by a lender.\r\n *\r\n * This class implements the builder pattern to provide a fluent-type API.\r\n */\r\nvar SeriesPayment = /** @class */ (function () {\r\n    function SeriesPayment() {\r\n        this._seriesPayment = new Series(SeriesType.Payment);\r\n    }\r\n    /**\r\n     * Instantiates a default instance of this class to capture user-defined input\r\n     */\r\n    SeriesPayment.builder = function () {\r\n        return new SeriesPayment();\r\n    };\r\n    /**\r\n     * The label assigned to each cash flow in the series. Used to annotate\r\n     * each cash flow in an amortisation schedule or calculation proof.\r\n     *\r\n     * @param label containing localised text in singular form e.g. 'Rental' (not 'Rentals')\r\n     */\r\n    SeriesPayment.prototype.setLabel = function (label) {\r\n        this._seriesPayment.label = label;\r\n        return this;\r\n    };\r\n    /**\r\n     * The total number of advances in the series. Default is 1.\r\n     *\r\n     * @param numberOf determining total number of cash flows in series\r\n     * @throws error when numberOf argument is less than 1\r\n     */\r\n    SeriesPayment.prototype.setNumberOf = function (numberOf) {\r\n        if (numberOf < 1) {\r\n            throw new Error(\"The numberOf value must be 1 or greater\");\r\n        }\r\n        this._seriesPayment.numberOf = numberOf;\r\n        return this;\r\n    };\r\n    /**\r\n     * The value of the one or more advances in the series. Leave the amount\r\n     * undefined if it is to be solved.\r\n     *\r\n     * @param amount to assign to each cash flow object created.\r\n     */\r\n    SeriesPayment.prototype.setAmount = function (amount) {\r\n        this._seriesPayment.amount = amount;\r\n        return this;\r\n    };\r\n    /**\r\n     * The posted date of the first advance in the series. Subsequent advance\r\n     * cash flow dates are determined with reference to this date *and* are offset\r\n     * by the interval defined by the series frequency.\r\n     *\r\n     * If the date is not defined it will be computed with reference to the current\r\n     * system date or the end date of a preceding advance series.\r\n     *\r\n     * @param payableFrom posted date of the first cash flow in the series\r\n     */\r\n    SeriesPayment.prototype.setDueOnOrFrom = function (payableFrom) {\r\n        this._seriesPayment.postedDate = payableFrom;\r\n        return this;\r\n    };\r\n    /**\r\n     * The compounding frequency of recurring advances in the series.\r\n     *\r\n     * @param frequency of the one or more advance cash flows in the series.\r\n     */\r\n    SeriesPayment.prototype.setFrequency = function (frequency) {\r\n        this._seriesPayment.frequency = frequency;\r\n        return this;\r\n    };\r\n    /**\r\n     * The mode of recurring payments in the series.\r\n     *\r\n     * @param mode of the one or more payment cash flows in the series\r\n     */\r\n    SeriesPayment.prototype.setMode = function (mode) {\r\n        this._seriesPayment.mode = mode;\r\n        return this;\r\n    };\r\n    /**\r\n     * The weighting of unknown payment series values relative to other unknown advance\r\n     * series values.\r\n     *\r\n     * @param weighting to apply to the payment cash flows in the series\r\n     * @throws error when weighting value is zero or negative\r\n     */\r\n    SeriesPayment.prototype.setWeighting = function (weighting) {\r\n        if (!(weighting > 0)) {\r\n            throw new Error(\"The weighting value must be greater than 0\");\r\n        }\r\n        this._seriesPayment.weighting = weighting;\r\n        return this;\r\n    };\r\n    /**\r\n     * Flag determines whether interest is to be compounded in line with the frequency of this\r\n     * payment series or not. Useful in defining payment series where interest is compounded at\r\n     * a different frequency e.g. monthly payments with quarterly compound interest.\r\n     *\r\n     * @param isIntCap\r\n     */\r\n    SeriesPayment.prototype.setIsIntCap = function (isIntCap) {\r\n        this._seriesPayment.isIntCap = isIntCap;\r\n        return this;\r\n    };\r\n    /**\r\n     * Method provides a reference to the populated instance after all user input has\r\n     * been captured.\r\n     */\r\n    SeriesPayment.prototype.build = function () {\r\n        return this._seriesPayment;\r\n    };\r\n    return SeriesPayment;\r\n}());\n\n// Calculator - standard API\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@curo/calculator/dist/index.es.js?");

/***/ }),

/***/ "./src/demo/demo01.ts":
/*!****************************!*\
  !*** ./src/demo/demo01.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar calculator_1 = __webpack_require__(/*! @curo/calculator */ \"./node_modules/@curo/calculator/dist/index.es.js\");\r\nvar schedule_builder_1 = __webpack_require__(/*! ../schedule-builder */ \"./src/schedule-builder.ts\");\r\nfunction runDemo01() {\r\n    // Problem definition\r\n    document.getElementById(\"demoTitle\").innerText = \"DEMO 1: Solve Unknown Payment, Compute Borrower's APR (Annual Percentage Rate)\";\r\n    document.getElementById(\"demoDef1\").innerText = \"An individual has applied for a loan of 10,000.00, repayable by 6 monthly instalments in arrears. A fee of 50.0 is payable with the first instalment. The lender's effective annual interest rate is 8.25%. This scenario is illustrated below.\";\r\n    document.getElementById(\"demoCfd\").src = \"./images/demo01.png\";\r\n    document.getElementById(\"demoDef2\").innerText = \"Using the US 30/360 day count convention, compute the value of the unknown instalments/payments and the borrower's APR.\";\r\n    var calc = new calculator_1.Calculator();\r\n    // Define the cash flow series\r\n    calc.add(calculator_1.SeriesAdvance.builder()\r\n        .setLabel(\"Loan advance\")\r\n        .setAmount(10000.0)\r\n        .build());\r\n    calc.add(calculator_1.SeriesPayment.builder()\r\n        .setNumberOf(6)\r\n        .setLabel(\"Instalment\")\r\n        .setMode(calculator_1.Mode.Arrear)\r\n        .build());\r\n    calc.add(calculator_1.SeriesCharge.builder()\r\n        .setLabel(\"Fee\")\r\n        .setAmount(50.0)\r\n        .setMode(calculator_1.Mode.Arrear)\r\n        .build());\r\n    // Calculate the unknown payment\r\n    var pmtResult = calc.solveValue(new calculator_1.US30360(), 0.0825);\r\n    document.getElementById(\"demoPayment\").innerText = \"Payment result: \" + pmtResult.toFixed(calc.precision);\r\n    // Calculate the borrower's APR\r\n    // - for loans taken out in EU member state\r\n    var rateDecimal = calc.solveRate(new calculator_1.EU200848EC());\r\n    // - for loans taken out in rest of world you could produce\r\n    //   a similar result using the XIRR feature of the provided\r\n    //   day count convention\r\n    // const rateDecimal = calc.solveRate(new US30360(undefined, true, true));\r\n    var ratePercent = rateDecimal * 100;\r\n    document.getElementById(\"demoRate\").innerText =\r\n        \"Borrower APR: \" + ratePercent.toFixed(1) + \"%  (to 1 decimal place)\";\r\n    // Display the results in a schedule\r\n    document.getElementById(\"demoSchedule\").appendChild(new schedule_builder_1.default(calc.profile, \"en-IE\").buildSchedule(rateDecimal));\r\n}\r\nexports.default = runDemo01;\r\n\n\n//# sourceURL=webpack:///./src/demo/demo01.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar demo01_1 = __webpack_require__(/*! ./demo/demo01 */ \"./src/demo/demo01.ts\");\r\n/*\r\n Each function below calculates the respective demo results which are displayed\r\n in the index.html page located in the project root folder. This single page is\r\n shared by all the demos which means only one function should be active at any\r\n time, therefore comment out all functions except the one being evaluated.\r\n */\r\ndemo01_1.default();\r\n// runDemo02();\r\n// runDemo03();\r\n// runDemo04();\r\n// runDemo05();\r\n// runDemo06();\r\n// runDemo07();\r\n// runDemo08();\r\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/schedule-builder.ts":
/*!*********************************!*\
  !*** ./src/schedule-builder.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar calculator_1 = __webpack_require__(/*! @curo/calculator */ \"./node_modules/@curo/calculator/dist/index.es.js\");\r\n/**\r\n * A utility class for building the demo amortisation and APR/XIRR proof schedules.\r\n *\r\n * This is a reference implementation which should be adapted in a real world application.\r\n */\r\nvar ScheduleBuilder = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of the schedule builder.\r\n     *\r\n     * @param profile containing the cash flows\r\n     * @param locale (optional) to use in formatting date and monetary output. Default is\r\n     * en-IE when undefined.\r\n     */\r\n    function ScheduleBuilder(profile, locale) {\r\n        this._profile = profile;\r\n        this._locale = [];\r\n        if (locale !== undefined) {\r\n            this._locale.push(locale);\r\n        }\r\n        this._locale.push(\"en-IE\");\r\n    }\r\n    /**\r\n     * Builds a schedule appropriate to the day count convention used in the calculation. There are\r\n     * two mutually exclusive schedule options, the first being an APR/XIRR calculation proof schedule,\r\n     * and the second an amortisation schedule.\r\n     *\r\n     * Where time periods between cash flows are determined with reference to the first cash\r\n     * flow date, as in APR and XIRR calculations, the method returns a calculation proof\r\n     * schedule. In all other cases an amortisation schedule is returned to prove the implicit\r\n     * interest rate within the cash flow profile produces a net future value of zero.\r\n     *\r\n     * @param aprResult\r\n     */\r\n    ScheduleBuilder.prototype.buildSchedule = function (aprResult) {\r\n        if (this._profile.dayCount.dayCountRef() === calculator_1.Convention.DRAWDOWN) {\r\n            // Annualised rate\r\n            return this.buildProof(aprResult !== undefined ? aprResult : 0.0);\r\n        }\r\n        else {\r\n            // Effective periodic rate\r\n            return this.buildAmort();\r\n        }\r\n    };\r\n    /**\r\n     * Builds an APR/XIRR calculation proof.\r\n     *\r\n     * @param aprResult\r\n     */\r\n    ScheduleBuilder.prototype.buildProof = function (aprResult) {\r\n        var containerDiv = document.createElement(\"div\");\r\n        var tbl = document.createElement(\"table\");\r\n        var caption = document.createElement(\"caption\");\r\n        caption.innerText = \"APR / XIRR Proof Schedule\";\r\n        tbl.appendChild(caption);\r\n        var thead = document.createElement(\"thead\");\r\n        var thr = thead.insertRow(0);\r\n        thr.insertCell(0).outerHTML = \"<th>Label</th>\";\r\n        thr.insertCell(1).outerHTML = \"<th>Date</th>\";\r\n        thr.insertCell(2).outerHTML = \"<th>Amount</th>\";\r\n        thr.insertCell(3).outerHTML = \"<th>Day Count Factor</th>\";\r\n        thr.insertCell(4).outerHTML = \"<th>Amount Discounted [1]</th>\";\r\n        tbl.appendChild(thead);\r\n        var tbody = document.createElement(\"tbody\");\r\n        var amtDiscTtl = 0;\r\n        for (var _i = 0, _a = this._profile.cashFlows; _i < _a.length; _i++) {\r\n            var cashFlow = _a[_i];\r\n            var amtDisc = cashFlow.value * Math.pow(1 + aprResult, -cashFlow.periodFactor.factor);\r\n            amtDiscTtl += amtDisc;\r\n            var tr = tbody.insertRow();\r\n            tr.insertCell().appendChild(document.createTextNode(cashFlow.label));\r\n            tr.insertCell().appendChild(document.createTextNode(cashFlow.postingDate.toLocaleDateString(this._locale)));\r\n            tr.insertCell().appendChild(document.createTextNode(cashFlow.value.toLocaleString(this._locale, {\r\n                minimumFractionDigits: this._profile.precision,\r\n                maximumFractionDigits: this._profile.precision\r\n            })));\r\n            tr.insertCell().appendChild(document.createTextNode(cashFlow.periodFactor.toString));\r\n            tr.insertCell().appendChild(document.createTextNode(amtDisc.toLocaleString(this._locale, {\r\n                minimumFractionDigits: 6,\r\n                maximumFractionDigits: 6\r\n            })));\r\n        }\r\n        tbl.appendChild(tbody);\r\n        var tfoot = document.createElement(\"tfoot\");\r\n        var fr = tfoot.insertRow(0);\r\n        fr.insertCell(0).outerHTML =\r\n            \"<td colspan='4'>Total of discounted amounts (should sum to zero)</th>\";\r\n        fr.insertCell(1).appendChild(document.createTextNode(amtDiscTtl.toLocaleString(this._locale, {\r\n            minimumFractionDigits: 6,\r\n            maximumFractionDigits: 6\r\n        })));\r\n        tbl.appendChild(tfoot);\r\n        containerDiv.appendChild(tbl);\r\n        var p1 = document.createElement(\"p\");\r\n        p1.appendChild(document.createTextNode(\"[1] Amount Discounted = Amount * ((1 + RateResultAsDecimal) ^ -Factor)\"));\r\n        containerDiv.appendChild(p1);\r\n        var p2 = document.createElement(\"p\");\r\n        p2.appendChild(document.createTextNode(\"This schedule demonstrates that the derived XIRR/APR result is mathematically correct; \\n      you can cross-check the result by substituting the inputs from each line into the formula\\n      at the bottom of the table and then sum the results (use the unrounded XIRR/APR result \\n      when you do this).\\n      Take note that the production of a proof schedule only makes sense in the context of APR\\n      and XIRR interest rate calculations where time periods are measured with reference to the\\n      initial drawdown date. For calculations based on compound interest use an amortisation\\n      schedule.\"));\r\n        containerDiv.appendChild(p2);\r\n        return containerDiv;\r\n    };\r\n    /**\r\n     * Builds an amortisation schedule.\r\n     */\r\n    ScheduleBuilder.prototype.buildAmort = function () {\r\n        var containerDiv = document.createElement(\"div\");\r\n        var tbl = document.createElement(\"table\");\r\n        var caption = document.createElement(\"caption\");\r\n        caption.innerText = \"Amortisation Schedule\";\r\n        tbl.appendChild(caption);\r\n        var thead = document.createElement(\"thead\");\r\n        var thr = thead.insertRow(0);\r\n        thr.insertCell(0).outerHTML = \"<th>Label</th>\";\r\n        thr.insertCell(1).outerHTML = \"<th>Date</th>\";\r\n        thr.insertCell(2).outerHTML = \"<th>Amount</th>\";\r\n        thr.insertCell(3).outerHTML = \"<th>Interest</th>\";\r\n        thr.insertCell(4).outerHTML = \"<th>Capital Balance</th>\";\r\n        tbl.appendChild(thead);\r\n        var tbody = document.createElement(\"tbody\");\r\n        var balanceCFwd = 0;\r\n        for (var _i = 0, _a = this._profile.cashFlows; _i < _a.length; _i++) {\r\n            var cashFlow = _a[_i];\r\n            if (cashFlow instanceof calculator_1.CashFlowCharge) {\r\n                // Do not include charges\r\n                continue;\r\n            }\r\n            balanceCFwd = calculator_1.MathUtils.gaussRound(balanceCFwd + cashFlow.value, this._profile.precision);\r\n            var tr = tbody.insertRow();\r\n            tr.insertCell().appendChild(document.createTextNode(cashFlow.label));\r\n            if (this._profile.dayCount.usePostingDates()) {\r\n                tr.insertCell().appendChild(document.createTextNode(cashFlow.postingDate.toLocaleDateString(this._locale)));\r\n            }\r\n            else {\r\n                tr.insertCell().appendChild(document.createTextNode(cashFlow.valueDate.toLocaleDateString(this._locale)));\r\n            }\r\n            tr.insertCell().appendChild(document.createTextNode(cashFlow.value.toLocaleString(this._locale, {\r\n                minimumFractionDigits: this._profile.precision,\r\n                maximumFractionDigits: this._profile.precision\r\n            })));\r\n            if (cashFlow instanceof calculator_1.CashFlowPayment) {\r\n                tr.insertCell().appendChild(document.createTextNode(cashFlow.interest.toLocaleString(this._locale, {\r\n                    minimumFractionDigits: this._profile.precision,\r\n                    maximumFractionDigits: this._profile.precision\r\n                })));\r\n                balanceCFwd = calculator_1.MathUtils.gaussRound(balanceCFwd + cashFlow.interest, this._profile.precision);\r\n            }\r\n            else {\r\n                tr.insertCell().appendChild(document.createTextNode(Number(0).toLocaleString(this._locale, {\r\n                    minimumFractionDigits: this._profile.precision,\r\n                    maximumFractionDigits: this._profile.precision\r\n                })));\r\n            }\r\n            tr.insertCell().appendChild(document.createTextNode(balanceCFwd.toLocaleString(this._locale, {\r\n                minimumFractionDigits: this._profile.precision,\r\n                maximumFractionDigits: this._profile.precision\r\n            })));\r\n        }\r\n        tbl.appendChild(tbody);\r\n        containerDiv.appendChild(tbl);\r\n        return containerDiv;\r\n    };\r\n    return ScheduleBuilder;\r\n}());\r\nexports.default = ScheduleBuilder;\r\n\n\n//# sourceURL=webpack:///./src/schedule-builder.ts?");

/***/ })

/******/ });